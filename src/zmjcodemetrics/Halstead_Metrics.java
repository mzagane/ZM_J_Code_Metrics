/**
 * ZM J Code Metrics
 * 
 * file : all codes related to halstead metrics  * 
 * src version: 01.06.2020
 * 
 * @author ZM (ZAGANE Mohammed)
 * @email : m_zagane@yahoo.fr
 */
package zmjcodemetrics;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.w3c.dom.Node;

/**
 *
 * @author ZM
 */
public class Halstead_Metrics {
    
    public static class Halst_Met
    {
        /**
        * Number of distinct operators : n1
        * Number of distinct operands  : n2
        * Total number of operators    : N1
        * Total number of operands     : N2
        **
        * From these numbers, several measures can be calculated:
        **
        * Program vocabulary           : n = n1+n2
        * Program length               : N=N1+N2
        * Calculated program length    : _N = n1*log(2)n1 + n2*log(2)n2
        * Volume                       : V= N * log(2)n
        * Difficulty                   : D = n1/2 * N2/n2
        * Effort                       : E = D * V
        * Time Required To Program     : T = E/18 seconds
        * Number of delivered bugs     : B = E^(2/3) / 3000  or  B = V/3000
        */

        long n1_Number_Of_Distinct_Operators;
        long n2_Number_Of_Distinct_Operands;
        long N1_Total_Number_Of_Operators;
        long N2_Total_Number_Of_Operands;
        long n_Program_Vocabulary;
        long N_Program_Length;
        double         _N_Calculated_Program_Length;
        double         V_Volume;
        double         D_Difficulty;
        double         E_Effort;
        double         T_Time_Required_To_Program;
        double         B_Number_of_Delivered_Bugs_1;
        double         B_Number_of_Delivered_Bugs_2;

    }
    
    
    private static final List <String> Halstead_Operand_Type = new ArrayList (
    
    Arrays.asList("LITERAL", "TYPE_SPECIFICATOR", "IDENTIFIER")
    ); // the tokens to be considired as operand
    
    private static final List <String> Halstead_Operator_Type = new ArrayList (
    
    Arrays.asList("STORAGE_CLASS_SPECIFICATOR", "TYPE_QUALIFICATOR", "KEY_WORD", "OPERATOR")
    ); // the tokens to be considired as operator
    
    /**
     * Get the list of halstead operands
     * @param Token_List : the list of tokens generated by 
     * Tokeniser.Generate_Token_List(...)  method
     * @return 
     */
    public static List<Halstead_Operand> Get_Halstead_Operand_List (List<Token> Token_List)
    {
        List<Halstead_Operand> Halstead_Operand_List = new ArrayList();
        
        for (Token A_Token : Token_List) 
        {
            if (Halstead_Operand_Type.contains(A_Token.Token_Type))
            {
                boolean Is_Found = false;
                int Index =0;
                for (Halstead_Operand H_O : Halstead_Operand_List)
                {
                    if(H_O.H_Operand.Token_Name == null ? A_Token.Token_Name == null : H_O.H_Operand.Token_Name.equals(A_Token.Token_Name))
                    {
                        Is_Found = true;
                        break;
                    }
                    else
                    {
                        Index ++;
                    }
                }
                
                if (Is_Found)
                {
                    Halstead_Operand_List.get(Index).H_Operand_Count = Halstead_Operand_List.get(Index).H_Operand_Count + 1;
                }
                else
                {
                    Halstead_Operand  Hal_Op = new Halstead_Operand();
                    Hal_Op.H_Operand = A_Token;
                    Hal_Op.H_Operand_Count = 1;
                    Halstead_Operand_List.add(Hal_Op);
                }
            }
        }
        return Halstead_Operand_List;
    }
    
    /**
     * Get the list of halstead operators
     * @param Token_List :the list of tokens generated by 
     * Tokeniser.Generate_Token_List(...)  method
     * @return 
     */
    public static List<Halstead_Operator> Get_Halstead_Operator_List (List<Token> Token_List)
    {
        List<Halstead_Operator> Halstead_Operator_List = new ArrayList();
        
        for (Token A_Token : Token_List) 
        {
            if (Halstead_Operator_Type.contains(A_Token.Token_Type))
            {
                boolean Is_Found = false;
                int Index =0;
                for (Halstead_Operator H_O : Halstead_Operator_List)
                {
                    if(H_O.H_Operator.Token_Name == null ? A_Token.Token_Name == null : H_O.H_Operator.Token_Name.equals(A_Token.Token_Name))
                    {
                        Is_Found = true;
                        break;
                    }
                    else
                    {
                        Index ++;
                    }
                }
                
                if (Is_Found)
                {
                    Halstead_Operator_List.get(Index).H_Operator_Count = Halstead_Operator_List.get(Index).H_Operator_Count + 1;
                }
                else
                {
                    Halstead_Operator  Hal_Op = new Halstead_Operator();
                    Hal_Op.H_Operator = A_Token;
                    Hal_Op.H_Operator_Count = 1;
                    Halstead_Operator_List.add(Hal_Op);
                }
            }
        }
        return Halstead_Operator_List;
    }
    
    /**
     * Calculate the halstead metrics
     * @param XML_Node : srcML node (for a file or function)
     * @param Language : src Language (c, c++,..)
     * @return 
     */
    public static Halst_Met Get_Halst_Met (Node XML_Node, String Language)
    {
        List<Token> Token_List;
        Token_List = new ArrayList();
        
        List<Halstead_Operand> Halstead_Operand_List;
        List<Halstead_Operator> Halstead_Operator_List;
        
        Halst_Met  H_M = new Halst_Met();
        
             
        Tokeniser.Generate_Token_List(XML_Node, Token_List, Language);
        
        //Halstead 
        Halstead_Operand_List = Halstead_Metrics.Get_Halstead_Operand_List(Token_List);
        Halstead_Operator_List = Halstead_Metrics.Get_Halstead_Operator_List(Token_List);
        
        H_M.n1_Number_Of_Distinct_Operators = Halstead_Operator_List.size();
        H_M.n2_Number_Of_Distinct_Operands = Halstead_Operand_List.size();
        
        long Temp =0;
        for (Halstead_Operand H_Operand : Halstead_Operand_List)
        {
            Temp = Temp + H_Operand.H_Operand_Count;
        }
        H_M.N2_Total_Number_Of_Operands = Temp;
        
        Temp =0;        
        for (Halstead_Operator H_Operator : Halstead_Operator_List)
        {
            Temp = Temp + H_Operator.H_Operator_Count;
        }
        H_M.N1_Total_Number_Of_Operators = Temp;
        
        //Program vocabulary : n, Program length : N
        H_M.n_Program_Vocabulary = H_M.n1_Number_Of_Distinct_Operators + H_M.n2_Number_Of_Distinct_Operands;
        H_M.N_Program_Length = H_M.N1_Total_Number_Of_Operators + H_M.N2_Total_Number_Of_Operands;
        //Calculated Program Length N'
        H_M._N_Calculated_Program_Length =
        H_M.n1_Number_Of_Distinct_Operators * log2(H_M.n1_Number_Of_Distinct_Operators) +
        H_M.n2_Number_Of_Distinct_Operands * log2(H_M.n2_Number_Of_Distinct_Operands);
        //program Volume : V, Program difficulty : D, Program Effort, Time Required To Program : T, Number of Delivered Bugs : B
        H_M.V_Volume = H_M.N_Program_Length * log2(H_M.n_Program_Vocabulary);
        H_M.D_Difficulty = (H_M.n1_Number_Of_Distinct_Operators/2) * (H_M.N2_Total_Number_Of_Operands/H_M.n2_Number_Of_Distinct_Operands);
        H_M.E_Effort = H_M.D_Difficulty * H_M.V_Volume;
        H_M.T_Time_Required_To_Program = H_M.E_Effort / 18;
        H_M.B_Number_of_Delivered_Bugs_1 = (Math.pow(H_M.E_Effort ,2/3)) / 3000;
        H_M.B_Number_of_Delivered_Bugs_2 = H_M.V_Volume / 3000;
        
        return H_M;
    }
    
    /**
     * Calculate the log base 2 of d
     * @param d : a double
     * @return 
     */
    private static double log2(double d) {
      return Math.log(d)/Math.log(2.0);
    }
}
